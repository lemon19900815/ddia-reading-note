[TOC]

# 事务

在一个苛刻的数据存储环境中，会有许多可能出错的情况，例如：

- 数据库软件或硬件可能会随时失效（包括正在执行写操作的过程中）。
- 应用程序可能随时崩溃（包括一系列操作执行道中间某一步）。
- 应用与数据节点之间的链接可能随时会中断，数据库节点之间也存在同样问题。
- 多个客户端可能同时写入数据库，导致数据覆盖。
- 客户端可能读到一些无意义的、部分更新的数据。
- 客户端之间由于边界条件竞争所引入的各种奇怪问题。

为了提高系统高可靠的目标，我们必须处理好上述问题，万一发生类似情况确保不会导致系统级的失效。然而，完善的容错机制需要大量的工作，要仔细考虑各种可能出错的可能，并进行充分的测试才能确保方案切实可靠。



## 深入理解事务

### ACID的含义

事务所提供的安全保证即大家所熟知的ACID，分别代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation）与持久性（Durability），取这四个特性的首字母。然而各家数据库所实现的ACID并不尽相同，当听到一个系统声称自己“兼容ACID”时，其实你无法确信它究竟能提供了什么样的保证，现在的ACID更像是一个市场营销用词。

#### 原子性

通常，原子是指不可分解为更小粒度的东西。这个属于在计算机的不同领域有着相似却微妙的差异。例如，多线程编程中，如果某线程执行一个原子操作，这意味着其他线程是无法看到该操作的中间结果。它只能处于操作之间或操作之后的状态，而不是两者之间的状态。

而ACID中的原子性并不关于多个操作的并发性，它并没有描述多个线程试图访问相同的数据会发生什么情况，后者是由ACID的隔离性所定义。

ACID的原子性其实描述了客户端发起一个包含多个写操作的请求时可能发生的情况，例如在完成了一部分写入之后，系统发生了故障，包括进程崩溃，网络中断，磁盘变满或违反了某种完整性约束等；把多个写操作纳入到一个原子事务，万一出现了上述故障而导致没法完成最终提交时，则事务会中止，并且数据库须丢弃或撤销那些局部完成的更改。

假如没有原子性保证，当多个更新操作中间发生了错误，就需要知道哪些更改已经生效，哪些没有生效，这个寻找过程会非常麻烦。或许应用程序可以重试，但情况类似，并且可能导致重复更新或者不正确的结果。原子性大大简化了这个问题：如果事务已经中止，应用程序可以确定没有实质发生任何更改，所以可以安全的重试。

因此ACID中的原子性所定义的特征是：**在出错时中止事务，并将部分完成的写入丢弃**。

#### 一致性

一致性非常重要，但它在不同场景有着不同的具体含义，例如：

- [第5章 数据复制](第5章 数据复制.md) 中讨论副本一致性以及异步复制模型时，引出了最终一致性问题（参见第5章 “复制滞后问题”）。
- 一致性hash则是某些系统用于动态分区再平衡的方法（参见第6章 “一致性hash”）。
- CAP理论中，一致性一词用来表示线性化（参见第9章 “可线性化”）。
- *而在ACID中一致性主要指数据库处于应用程序所期待的“预期状态”*。

可以看出，同一个词至少有四种不同的含义。

**ACID中的一致性主要是指对数据有特定的预期状态，任何数据更改必须满足这些状态约束（或者恒等条件）**。例如，对于一个账单系统，账户的贷款余额应和借款余额保持平衡。如果某事务从一个有效的状态开始，并且事务中任何更新操作都没有违背约束，那么最后的结果依然符合有效状态。

这种一致性本质上要求应用层来维护状态一致（或者恒等等），应用程序有责任正确地定义事务来保持一致性。这不是数据库可以保证的事情：即如果提供的数据修改违背了恒等条件，数据库很难检测进而阻止该操作（数据库可以完成针对某些特定类型的恒等约束检查，例如使用外键约束或唯一性约束。但通常主要靠应用程序来定义数据的有效/无效状态，数据库主要负责存储）。

*原子性，隔离性和持久性是数据库自身的属性，而ACID中的一致性更多的是应用层的属性。应用程序可以借助数据库提供的原子性和隔离性，以达到一致性，但一致性本身并不源于数据库*。

#### 隔离性

大多数数据库都支持多个客户端同时访问。如果读取和写入的是不同数据，这肯定没有什么问题，但如果访问相同的记录，则可能会遇到并发问题（即带来竞争条件）。

一个简单的例子：同时递增一个计数器产生竞争条件。

假如有2个客户端同时增加数据库中的一个计数器。每个客户首先读取当前值，再+1，然后写回新值（这里假设数据库尚不支持自增操作）。图7-1中，由于2次相加，计数器应该由42增加到44，但实际上由于竞争条件最终结果确实43。

*ACID语义中的隔离性意味着并发执行的多个事务相互隔离，它们不能相互交叉*。经典数据库教材把隔离定义为可串行化，这意味着可以假装它是数据库上运行的唯一事务。虽然实际上它们可能同时运行，但数据库系统要确保当事务提交时，其结果与串行执行（一个接一个执行）完全相同。然而实践中，由于性能问题很少使用串行化隔离。

![2个客户端同时递增一个计数器](/img/图7-1.png)

**图7-1: 2个客户端同时递增一个计数器产生竞争条件**

#### 持久性

数据库系统本质上提供一个安全可靠的地方来存储数据而不担心数据丢失等。持久性就是这样的承诺，它保证一旦事务提交成功，即使存在硬盘故障或数据库崩溃，事务所写入的任何数据也不会消失。

对于单节点数据库，持久性通常意味着数据已被写入非易失性存储设备，如硬盘或SSD。在写入执行过程中，通常还涉及预写日志等（WAL），这样万一磁盘损坏可以进行恢复。而对于支持远程复制的数据库，持久性则意味着数据已成功复制到多个节点。为了实现持久性的保证，数据库必须等到这些写入或复制完成之后才能报告事务成功提交。

不存在完美的持久性方案。例如，所有的硬盘和所有的备份如果都同时被（人为）销毁了，那么数据库也无能为力。



### 单对象与多对象事务操作

ACID中的原子性和隔离性主要针对客户端在同一事务中包含多个写操作时，数据库所提供的保证：

原子性

​		如果一系列的写操作中间发生了错误，则事务必须中止，并且事务中已完成的写入应该被丢弃。换言之，不用担心数据库的部分失败，它总是保证要么成功，要么失败。

隔离性

​		同时运行的事务不应该相互干扰。例如，如果某个事务进行多次写入，则另一个事务应该观察到是其全部完成（或者一个都没完成）的结果，而不应该看到中间的部分结果。

这些定义假定在一个事务中会修改多个对象（如：行，文档，记录等）。这种多对象事务目的通常是为了哎多个数据对象之间保持同步。

#### 单对象写入

原子性和隔离性也同样适用于单个对象的更新。

高级的原子操作，原子比较-设置操作（compare-and-set），即只有当前值没有被他人修改时才执行写入。这些单对象操作可以有效防止多个客户端并发修改同一对象时的更新丢失问题。但它们都不是通常意义上的事务。

*通常意义上的事务针对的是多个对象，将多个操作聚合为一个逻辑执行单元*。

#### 多对象事务的必要性

许多分布式数据存储系统不支持多对象事务，主要是因为当出现分区时，多对象事务非常难以正确实现，同时在高可用或者极致性能的场景下也会带来很多负面影响。

是否所有应用都需要对对象事务呢？是否可能只用键-值数据模型和单对象操作就可以满足应用需求？

的确有一些情况，只进行单个对象的插入、更新和删除就足够了。但是，还有许多其他情况要求写入多个不同的对象进行协调：

- 对于关系型数据模型，表中的某行可能是另一个表的外键。类似地，在图数据模型中，顶点具有多个边链接到其他的顶点。多对象事务用以确保这些外键引用的有效性，即当插入多个相互引用的记录时，保证外键总是最新、正确的，否则数据更新就变得毫无意义。
- 对于文档数据模型，如果待更新的字段都在同一个文档中，则可视为单个对象，此时不需要多对象事务。但是，缺少join支持的文档数据库往往会滋生反规则化，当更新这种反规范化数据时，就需要一次更新多个文档。此时多对象事务就可以有效防止非规范化数据之间出现不同步。
- 对于带有二级索引的数据库（除了纯粹键-值存储以外几乎所有其他系统都支持二级索引），每次更改值时都需要同步更新索引。从事务角度来看，这些索引是不同的数据库对象：如果没有事务隔离，就会出现部分索引更新。

即使没有事务支持，或许上次应用依然可以工作，然后在没有原子性保证是，错误处理就会异常复杂，而缺乏隔离性则容易出现并发性方面的各种奇怪问题。

#### 处理错误与中止

*事务的一个关键特性是，如果发生了以外，所有操作被中止，之后可以安全的重试*。**ACID数据库基于这样一个理念：如果存在违反原子性、隔离性或持久性的风险，则完全放弃整个事务，而不是部分放弃**。

然而并不是所有的系统都遵守上述理念。我们确实无法彻底避免错误，然后许多开发人员喜欢只考虑正常的处理路径，而忽视错误处理。这绝不应该，*支持安全的重试机制才是中止流程的重点*。

重试中止的事务虽然是一个简单有效的错误处理机制，但它并不完美：

- 如果事务实际已经执行成功，但返回给客户端的消息在网络传输时发生以外（所以在客户端开始事务是失败的），那么重试就会导致重复执行，此时需要额外的应用级重复数据删除机制。
- 如果错误是由于系统超负荷所导致，则重试事务将使情况变得更糟。为此，可以设置一个重试次数上限，例如指数回退（见TCP重连机制），同时还要尝试解决系统过载本身的问题。
- 由临时性故障（如：死锁，隔离违例，网络闪断和节点切换等）所导致的错误需要重试。但出现永久性故障（如违反约束），则重试毫无意义。
- 如果在数据库之外，事务还产生其他副作用，即使事务被中止，这些副作用可能已事实生效。例如，假设更新操作还附带发送一封电子邮件，肯定不希望每次重试都发送邮件（注：这样设计本身存在问题，作者只是在这里举了一个不恰当的例子，但可以反应作者在这里的观点）。如果想要确保多个不通过的系统同时提交或放弃，可以考虑采用两阶段提交（`2PC: 2 phase commit`，参考第9章 “原子提交与两阶段提交”）。
- 如果客户端进程在重试过程中发生失败，没有其他人继续负责重试，则那些待写入的数据可能会因此而丢失。

## 弱隔离级别



## 串行化

